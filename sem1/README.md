# Семинар 1

## Важные утилиты (список можно гуглить + смотреть в /bin)
* cat file (вывести содержимое файла file в stdout)
* touch file (создать файл file)
* mkdir dir (создать директорию dir)
* rm file (удалить файл, с -r флагом можно директорию, универсальная команда `rm -rf`)
* ps (вывести список процессов, общий паттерн `ps auxf`)
* grep smth (вывести строки, в которых содержится как подстрока smth)
* echo (вывести в stdout что угодно, популярный паттерн echo $PATH)
* wc (количество строк, символов и тп)
* kill (послать сигнал процессу, в частности убить процесс `kill -9 pid`)
* chmod (изменить маску доступов, `chmod +x file` - сделать file исполняемым)
* chown (изменить владельца файлом)
* ls (посмотреть список директории, `ls -la` - подробный вывод)
* htop/top ("загруженность системы")
* ulimit (посмотреть soft и hard ulimits)

## Важные файлы
`~/.bashrc` - конфиг окружения терминала
`~/.vimrc` - конфиг для вима, позволяющий его превратить в полноценное IDE
`~/.gdbinit` - конфиг для gdb

## Полезные расширения
Peda - расширение для gdb
```
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
echo "DONE! debug your program with gdb and enjoy"
```

## Тезисы
* Есть user space и kernal space. US общается с KS через syscalls, обратно через signals.
* Все процессы создаются через `fork + exec`.
* Начальный процесс - init.
* Процессы образуют дерево.
* Любая программа создается в новом процессе. (/bin/kill тоже создает процесс)
* Unix строится по вере, что все есть файлы (но оказалось, что это не так).

## Чеклист самопроверки
* Найти количество строк в логе log.txt со статусом 200
* С помощью GDB найти пароль для `hackme`
* Создать бомбу `bomb.sh` и попробовать ее убить из другого окна

## Попробуйте ответить на вопросы
* Откуда `htop/top` берет инфу о процессах? Подумайте о том, что все есть файл. Поисследуйте корневую директорию `/`.

## Вопросы с семинара
* chown 777 (почему сработало?)
* kill as signal
